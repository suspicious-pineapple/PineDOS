	BITS 16
	ORG 0x7C00		; We are loaded by BIOS at 0x7C00
	;define location where kernel will be loaded- after this 512 byte bootloader
	;0x7c00 (origin) + 0x200 (512 bytes) = 0x7e00

jmp short BL_skip
nop





db 0x6D,0x6B,0x66,0x73,0x2E,0x66,0x61,
db 0x74,0x00,
db 0x02,0x01,0x01,0x00,0x01,0xE0,0x00,0xE0,0x15,0xF8,0x16,0x00,0x20,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x29,0x69,0x69,0x69,0x69,0x50,0x49,0x4E,0x45,0x44,0x4F,0x53,0x38,0x36,0x20,0x20,0x46,0x41,0x54,0x31,0x36,0x20,0x20,0x20
fs_sector equ 23


















	
	;.VBR:
	;FAT_OEM_STR db "PINEDOS0" ;8 byte OEM info
	;FAT_BYTES_PER_SECTOR dw 512 ;bytes per sector, 512
	;FAT_SECTORS_PER_CLUSTER db 1 ;sectors per cluster
	;FAT_RESERVED_SECTORS dw 1 ;reserved sectors
	;FAT_NUM_TABLES db 1 ;number of file allocation tables
	;FAT_NUM_ROOT_ENTRIES dw 16 ;128 root directory entries
	;FAT_TOTAL_LOGICAL_SECTORS dw 512
	;FAT_MEDIA_DESCRIPTOR db 0xf0 ; 3.5-inch (90 mm) double sided, 80 tracks per side, 18 or 36 sectors per track (1440 KB, known as "1.44 MB" or 2880 KB, known as "2.88 MB").
	;FAT_SECTORS_PER_TABLE dw 1
	;FAT_SECTORS_PER_TRACK dw 18
	;FAT_NUM_HEADS dw 2
	;FAT_HIDDEN_SECTORS dw 0
	;dw 0
	;FAT_LARGE_SECTOR_COUNT dw 0
	;dw 0
;
	;;Extended boot record
	;FAT_DRIVE_NUMBER db 0
	;FAT_NT_FLAGS db 0
	;FAT_SIGNATURE db 0x28
	;FAT_VOLUME_ID dd 0
	;FAT_VOLUME_LABEL db "PineDOS    "
	;FAT_SYS_IDENTIFIER db "SUSSYSTR"
	


	kernel_address equ 0x7c00+512
	


;origin is 0x7c00

BL_skip:
mov [BL_devicenum], dl

	
BL_start:

	;mov ax, 07C0h		; Set up 4K stack space after this bootloader
    ;07c0h * 16 = 0x7c00, bootloader starts at 0x7c00

	;add ax, 288		; (4096 + 512) / 16 bytes per paragraph,
    ; 288*16-512 = 4096    
	;mov ss, ax
	;mov sp, 4096

	;mov ax, 07C0h		; Set data segment to where we're loaded
	;mov ds, ax

	mov ax, 0x1000
	mov ss, ax
	mov sp, 0xFFFF
	mov ax, 0
	mov ds, ax
	mov es, ax


	;mov ah, 00h
	;mov al, 02h
	;call print_hex
	;jmp $


	mov si, BL_bootmsg
	call BL_print_string
	

	mov al, byte [BL_devicenum]
	call BL_print_hex



	call BL_newline

	;read 16kb worth of sectors after the bootloader
		;want the data at = 0x08E0h:0x0000
	;set ES:BX to 0x08E0h:0x0000

	mov bx, (kernel_address)
	;mov bx, loadhere
	;mov ax, 8E0h
	;mov es, ax
	
	mov ah, 02h ;read sectors
	mov al, 20h ;32 sectors
	
	mov ch, 0h ;cyliner 0
	;mov cl, 02h ;start at sector 1
	mov cl, 2 ;start at sector 1
	
	mov dh, 00h ;head 0
	mov dl, byte [BL_devicenum] ;drive 0, floppy drive
	int 13h

	mov ah, 01h
	mov dl, 00h
	;clear carry flag
	stc
	int 13h
	jnc .success
	.readError:
		mov al, ah
		call BL_print_hex
		mov si, BL_errormsg
		call BL_print_string
		inc word [BL_attempt]
		cmp word [BL_attempt], 3
		jl BL_start
		mov si, BL_resetmsg
		call BL_print_string
		mov ah, 00h
		mov dl, 00h
		int 13h
		mov al, ah
		call BL_print_hex
		mov word [BL_attempt], 0
		jmp BL_start
	.success:
	mov si, BL_successmsg
	call BL_print_string
	call BL_newline

	call BL_newline

	;jmp short (0x7c00+512+4096)
	;jmp kernel_address
	jmp BL_loadhere

	;print out the 512 bytes of data that was read, dump it to the screen using print_hex in a grid
	mov si, (kernel_address)
	mov cx, 512
	.dump:
		lodsb
		mov ah, 0Eh
		int 10h
		inc si
		loop .dump
	

	call BL_newline



	;jmp $


	BL_print_string:			; Routine: output string in SI to screen
	mov ah, 0Eh		; int 10h 'print char' function
	.repeat:
		lodsb			; Get character from string
		cmp al, 0
		je .done		; If char is zero, end of string
		int 10h			; Otherwise, print it
	jmp .repeat
	.done:
		ret


	
	BL_print_hex:
		pusha
		;check if greater than 16
		cmp al, 0Fh
		jl .lessthan
		;print letter X
		mov al, 'X'
		mov ah, 0Eh
		int 10h
		popa
		ret
		.lessthan:

		;use int 10h to print the character after converting it to ascii
		add al, 30h
		cmp al, 39h
		jle .print
		add al, 7h
		.print:
		mov ah, 0Eh
		int 10h
		popa
	
	BL_newline:
		pusha
		mov ah, 03h
		mov bh, 0
		int 10h
		inc dh
		mov dl, 0
		mov ah, 02h
		int 10h
		popa
	ret






	;strings
	BL_bootmsg db 'trying to read drive nr:', 0

	BL_beforedump db 'dumping memory: ', 0
	BL_errormsg db ' -> drive error! retrying.. ', 0
	BL_successmsg db 'drive read successful!', 0
	BL_resetmsg db ' exceeded attempts, resetting drive, result:', 0
	


	;data
	BL_attempt dw 0
	BL_devicenum db 0












	times 510-($-$$) db 0	; Pad remainder of boot sector with 0s
	dw 0xAA55		; The standard PC boot signature

	db 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,0xFF

;include kernel.asm here




;example file:
;4B
;45 52 4E 45 4C 31 36 42 49 4E 20

;0x10 -> Type

;0xBA -> Reserved

;0x27 -> Time, seconds

;0xFA15

;0xFA5A


;0x005A

;00
;43
;15
;FA
;5A
;04
;00
;0x0000001C

	times (512*23)-($-$$) db 0



	;db 0x50, 0x49, 0x4E , 0x45 , 0x44 , 0x4F , 0x53 , 0x38 , 0x36 , 0x20 , 0x20 , 0x08 , 0x00 , 0x00 , 0x12 , 0x1E , 0xFB , 0x5A , 0xFB , 0x5A , 0x00 , 0x00 , 0x12 , 0x1E , 0xFB , 0x5A , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x42 , 0x20 , 0x00 , 0x49 , 0x00 , 0x6E , 0x00 , 0x66 , 0x00 , 0x6F , 0x00 , 0x0F , 0x00 , 0x72 , 0x72 , 0x00 , 0x6D , 0x00 , 0x61 , 0x00 , 0x74 , 0x00 , 0x69 , 0x00 , 0x6F , 0x00 , 0x00 , 0x00 , 0x6E , 0x00 , 0x00 , 0x00 , 0x01 , 0x53 , 0x00 , 0x79 , 0x00 , 0x73 , 0x00 , 0x74 , 0x00 , 0x65 , 0x00 , 0x0F , 0x00 , 0x72 , 0x6D , 0x00 , 0x20 , 0x00 , 0x56 , 0x00 , 0x6F , 0x00 , 0x6C , 0x00 , 0x75 , 0x00 , 0x00 , 0x00 , 0x6D , 0x00 , 0x65 , 0x00 , 0x53 , 0x59 , 0x53 , 0x54 , 0x45 , 0x4D , 0x7E , 0x31 , 0x20 , 0x20 , 0x20 , 0x16 , 0x00 , 0x07 , 0x35 , 0x1E

	db 0x50, 0x49, 0x4E, 0x45, 0x44, 0x4F, 0x53, 0x38, 0x36, 0x20, 0x20, 0x08, 0x00, 0x00, 0x12, 0x1E, 0xFB, 0x5A, 0xFB, 0x5A, 0x00, 0x00, 0x12, 0x1E, 0xFB, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x20, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x0F, 0x00, 0x72, 0x72, 0x00, 0x6D, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x01, 0x53, 0x00, 0x79, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x0F, 0x00, 0x72, 0x6D, 0x00, 0x20, 0x00, 0x56, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x75, 0x00, 0x00, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x53, 0x59, 0x53, 0x54, 0x45, 0x4D, 0x7E, 0x31, 0x20, 0x20, 0x20, 0x16, 0x00, 0x07, 0x35, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00


	db 0x54, 0x45, 0x58, 0x54, 0x46, 0x49, 0x4C, 0x45, 0x54, 0x58, 0x54, 0x20, 0x10, 0x7F, 0xBC, 0x11, 0xFC, 0x5A, 0xFC, 0x5A, 0x00, 0x00, 0xE2, 0x10, 0xFC, 0x5A, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00



	.FAT:
	;KERNEL_FILENAME db "KERNEL16BIN"
	;KERNELFILE_ATTR db 0x01 ;readonly
	;db 0 ; reserved
	;db 0x27 ; creation time seconds
	;dw 0xFA15 ; creation time
	;dw 0xFA5A ; creation date
	;dw 0xFA5A ; last access date
	;dw 0 ; high 16 bits of cluster number. 0 because FAT16
	;dw 0xFA15 ; last modified time
	;dw 0xFA5A ; last modified date
	;dw 7 ; low 16 bits of the files cluster number. uhhh
	;dd 128 ; size of the file

	
	;db "TXTFILE0TXT"
	;db 0x01 ;readonly
	;db 0 ; reserved
	;db 0x17 ; creation time seconds
	;dw 0xFA15 ; creation time
	;dw 0xFA5A ; creation date
	;dw 0xFA5A ; last access date
	;dw 0 ; high 16 bits of cluster number. 0 because FAT16
	;dw 0xFA15 ; last modified time
	;dw 0xFA5A ; last modified date
	;dw 4 ; low 16 bits of the files cluster number. uhhh
	;dd 59 ; size of the file
;






	;times (512*27)-($-$$) db 0
	;db "This is a test for a simple text file. It is 59 bytes long."
	;times (512*29)-($-$$) db 0



		BL_loadhere:
	;%include "kernel.asm"
times (512*40)-($-$$) db 0
db "i like snails :D"

times (512*512+1)-($-$$) db 0
